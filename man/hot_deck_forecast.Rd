% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecast.R
\name{hot_deck_forecast}
\alias{hot_deck_forecast}
\title{Produce a hot deck forecast.}
\usage{
hot_deck_forecast(
  .data,
  .datetime,
  .observation,
  times,
  h,
  window_back = 20,
  window_fwd = 20,
  n_closest = 5,
  sampler = sample_lead("next_obs"),
  covariate_forecasts = NULL
)
}
\arguments{
\item{.data}{tsibble. The data.}

\item{.datetime}{symbol. The datetime column of \code{.data}.}

\item{.observation}{symbol. The observation column of \code{.data}.}

\item{times}{integer. The number of simulated sample paths to produce.}

\item{h}{integer. How many days to forecast.}

\item{window_back}{integer (scalar OR vector).
How many days back to include in the window for a given season.
Either scalar (length == 1) or vector of length == h.}

\item{window_fwd}{integer (scalar OR vector).
How many days forward to include in the window for a given season.
Either scalar (length == 1) or vector of length == h.}

\item{n_closest}{integer (scalar OR vector).
The number of closest observations to pick from per hot deck random sampling.
Either scalar (length == 1) or vector of length == h.}

\item{sampler}{Sampler function to generate forecasted values.}

\item{covariate_forecasts}{optional tsibble. Simulated sample paths of covariates.}
}
\value{
tibble of forecasts:
\itemize{
\item nrow = h * times,
\item columns:
\itemize{
\item datetime: the date for the forecast
\item h: the forecast horizon
\item forecast: the forecasted value
\item simulation_num: the simulated sample path number
}
}
}
\description{
Produces multiple h-step forecast simulated sample paths.
}
\details{
For \code{times} times, it produces a simulated sample path. For each
simulation, the process proceeds as follows:
This method is iterative. At the most recent observation, it:
\itemize{
\item Takes all historical observations from a window around
the same portion of the season.
\itemize{
\item e.g., Jun 30 +- 5 days across all years.
}
\item Takes the \code{n_closest} closest observations from these.
\item Randomly selects one of these \code{n_closest} observations.
\item Uses the observation of the day after that one as the forecasted value.
\item Repeats, using this new forecasted value and its respective date as
the new "most recent observation", up to h forecasts.
}

\code{window_back}, \code{window_fwd}, and \code{n_closest} can either each be a scalar
(i.e. length 1), or a vector of length h. If a scalar, the same value is
used for every horizon. If a vector, then for horizon h_i, the ith value
is used. This may be useful as the borders of periodically missing data,
where something like \code{window_fwd = c(1:10, rep(10,20))}, and maybe the same
for \code{window_back} could be used to ensure symmetric windows near the border.

The \code{sampler} function is what produces the actual forecasted values. It
takes the local rows and current value (plus some other params), and returns
a new current value and a forecasted value, which may or may not be the same.

This design allows for custom sampler functions to be supplied.

\code{covariate_forecasts}, if provided, must adhere to the following:
\itemize{
\item It must be a \code{tsibble}.
\item The simulation number (sample path) must go from 1 to (# of simulations),
and must be made the "key" of the tsibble.
So, your tsibble's "key" must be the covariate forecast's simulation number,
its "index" must be the temporal column, and its "measures" (everything
else) should be the covariates.
All of the \code{covariate_forecasts} "measure"s (filtered by each simulation number)
will be passed to the \code{sampler}, and that returned value (a partial application)
will be used to simulate a sample path.
The number of simulated sample paths generated per covariate simulation is
the ceiling of (\code{times} / (# of covariate simulations))
}
}
\examples{
data = append_diff(hotdeckfc::SUGG_temp, observation)
data = trim_leading_nas(data, observation)
out = hot_deck_forecast(data,
                        .datetime = date,
                        .observation = observation,
                        times = 3,
                        h = 20,
                        window_back = 20,
                        window_fwd = 20,
                        n_closest = 5,
                        sampler = sample_diff())  # don't forget to call!

}
